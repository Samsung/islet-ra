# FIXME

THIS FILE NEEDS TO BE ADAPTED TO THE NEW ISLET-RA REPOSITORY.

# Introduction

The process consists of several parts:

* provisioning
* gathering measurements
* feeding measurements to veraison and realm verifier
* running realm to verify
* running verification services (veraison/realm verifier)
* verification itself

It is best and even sometimes required that all the required repos are placed in
one directory. I'll call it `CCA` and it will be referred throughout this file.

The following repos will be used (they have some additional dependencies like
`rust-rsi`, `ratls` and `realm-verfier`, but it's not required to clone those
repos manually):

* camellia-hes: https://github.sec.samsung.net/SYSSEC/camellia-hes
* linux-rsi: https://github.sec.samsung.net/SYSSEC/linux-rsi
* fvp-cca-scripts: https://github.sec.samsung.net/SYSSEC/fvp-cca-scripts
* rim-extractor: https://github.sec.samsung.net/SYSSEC/rim-extractor
* rocli: https://github.sec.samsung.net/SYSSEC/rocli
* veraison: https://github.com/veraison/services
* realm-verifier: https://github.sec.samsung.net/SYSSEC/realm-verifier

No need to clone, just for completeness:

* rust-rsi: https://github.com/havner/rust-rsi
* ratls: https://github.sec.samsung.net/SYSSEC/ratls

# Provisioning

This is emulated by generating CPAK public key using one of camellia-hes
utilities:

    CCA/camellia-hes/cpak-generator $ cargo run

This will by default generate a CPAK using dummy GUK and dummy BL2 hash files
from `CCA/camellia-hes/res` directory and save both key binary and PEM format
respectively as:

    CCA/camellia-hes/out/cpak_public.bin
    CCA/camellia-hes/out/cpak_public.pem

# Gathering measurements

There are 2 things we need to measure here. Platform and realm.

## Plaftorm measurement

The platform measurement is done by getting the whole CCA token. Platform
measurements are saved there.

This is performed by some specifically prepared realm (e.g. one provided by
`fvp-cca-scripts`). To do this do the following:

    CCA/fvp-cca-scripts $ ./scripts/fvp-cca.sh init
    CCA/fvp-cca-scripts $ ./scripts/fvp-cca.sh build
    CCA/linux-rsi $ make

The first command will initialize the scripts and download all required
components. The second command will build the platform and the realm and prepare
the output directories. The third command will compile RSI module and command
line tool and will place them in the fvp-cca-scripts directory structure, in the
shared directory that will be visible for the realm.

Now we need to run HES:

    CCA/camellia-hes/camellia-hes-host-app $ cargo run -- -t

And we need to run the FVP:

    CCA/fvp-cca-scripts $ ./scripts/fvp-cca.sh run

If run under X terminals should open with telnet 5000/5003. If not we can run
those telnets manually on two separate terminals:

    $ telnet localhost 5000
    $ telnet localhost 5003

Port 5000 is the main terminal with console. 5003 is RMM. We don't need the
second for now, but the telnet itself is necessary for FVP to work
properly. When booting the TF-A is modified to talk to HES over the serial on
port 5002. No need to configure anything, it should work out of the box and the
result of this communication should be visible on both, the camelia-hes-host-app
terminal and on the 5000 telnet when TF-A is booting.

When the FVP linux is booted we need to run the realm:

    Welcome to Buildroot, type root or test to login
    buildroot login: root
    # cd /shared
    # ./realm.sh

This will take a lot of time (FVP is slow). Wait until you have a realm
shell. Then load RSI module and get the token:

    ~ # cd /shared
    /shared # ./module.sh
    /shared # ./rsictl attest -o token.bin

For the token part challenge value will be randomized, but in here it doesn't
matter. Now we can kill the FVP (ctrl-c on the FVP terminal). Eventually the
following command may be required as FVP doesn't always close cleanly:

    $ pkill -9 -i fvp

The generated token is saved as the following file:

    CCA/fvp-cca-scripts/out/shared_dir/token.bin

## Realm measurement

Realm measurement is done by generating a json file containing realm information
that will be fed to realm verifier.

This is performed by a small helper program called `rim-extractor`. It basically
runs the realm with a modified RMM that will display and intercept the RIM
value. The process looks as follows:

* generate/get the realm you want to use (for now generated by fvp-cca-scripts,
  those files can be taken from `CCA/fvp-cca-scripts/out/shared_dir`,
  `Image.realm initramfs-realm.cpio.gz lkvm realm.sh`)
* copy the realm files we want to measure to `CCA/rim-extractor/cca/realm`
* make sure no other FVP is running currently
* run the `rim-extractor`

Example:

    CCA/rim-extractor $ ls -l cca/realm/
    total 19212
    -rw-rw-r-- 1 havner havner 15272448 Aug 11 16:48 Image.realm
    -rw-rw-r-- 1 havner havner  1636861 Aug 11 16:49 initramfs-realm.cpio.gz
    -rwxrwxr-x 1 havner havner  2854576 Aug 11 16:49 lkvm
    -rwxrwxr-x 1 havner havner     1122 Aug 11 16:49 realm.sh
    CCA/rim-extractor $ cargo run
    (...)
    Realm JSON 'CCA/rim-extractor/json/realm.json' written

The resulting json is saved as the following file:

    CCA/rim-extractor/json/realm.json

Caveat: only RIM is supported for now, the REMs are placeholders.

# Provisioning/Measurement summary

Those 2 processes should end with the following things

* Prepared realm that won't be modified anymore:
  `Image.realm initramfs-realm.cpio.gz lkvm realm.sh`
  For now we use the one generated by fvp-cca-scripts
* Public CPAK key: `cpak_public.bin cpak_public.pem`
* Platform measurement: `token.bin`
* Realm measurement: `realm.json`

Those token and measurement files should be _sent_ to verification services
using a _safe_ communication channel.

# Running realm to verify

This is done in the same way we run realm to get the token.

Run the HES:

    CCA/camellia-hes/camellia-hes-host-app $ cargo run -- -t

Run the FVP with network this time:

    CCA/fvp-cca-scripts $ ./scripts/fvp-cca.sh net_start
    CCA/fvp-cca-scripts $ ./scripts/fvp-cca.sh run

Connect to terminals (or use those spawned in X):

    $ telnet localhost 5000
    $ telnet localhost 5003

When FVP is booted run the realm:

    Welcome to Buildroot, type root or test to login
    buildroot login: root
    # cd /shared
    # ./realm.sh

Load the RSI module:

    ~ # cd /shared
    /shared # ./module.sh

# Running and provisioning verification services (Veraison, realm-verifier)

First of all, before deploying Veraison, apply a patch to Veraison code:

    CCA/services $ cat ../rocli/veraison-patch | git apply

Then it's possible to deploy a Veraison Docker and source some useful
commands from veraison env file:

    CCA/services $ make docker-deploy
    CCA/services $ source deployments/docker/env.bash

Check if all 3 veraison services are running:

    $ veraison status
             vts: running
    provisioning: running
    verification: running

Now install go dependencies for rocli script:

    $ go install github.com/veraison/corim/cocli@latest
    $ go install github.com/veraison/ear/arc@latest
    $ go install github.com/veraison/evcli@latest

And run provisioning of token and cpak in PEM format:

    CCA/rocli/demo $ ./run.sh -t <path/to/token.bin> -k <path/to/cpak_public.pem>

This will provision a reference token and public CPAK to allow
Veraison verification.

It's possible to see current values stored in Veraison:

    $ veraison stores

And if required, they also should be cleared before they can be
provisioned again:

    $ veraison clear-stores

Run realm-verifier binary, which is provisioned with `realm.json` and
acts as Reliant Party with communication to realm and Veraison
services (this binary takes several parameters, most should not be of
any concern apart from passing latest reference values in `realm.json`):

    CCA/realm-verifier $ cargo run -- -r <path/to/realm.json>

If needed, '-b' option can be used to pass different network interface binding:

    CCA/realm-verifier $ cargo run -- -r <path/to/realm.json> -b <LOCAL_IP:PORT>

Realm-verifier awaits on given IP:PORT for communication from Realm and
utilizes our `ratls` Rust library and `realm-verifier` library (for `realm.json`
reference values verification) to verify client CCA token.

# Verification itself

On the realm side (the one we already run) just trigger the verification
process. This is done using `rsictl` tool as well. It will initialize RATLS
connection to verification service by performing the necessary steps:

* receive challenge value from verification service
* request the token from RMM/TF-A/HES using the challenge
* send the received token to verification service
* establish safe connection if verification services agrees to do so

This is done with the following command on the realm:

    shared # ./rsictl ra-tls -r root-ca.crt -u <SERVER_IP:PORT>

That command will take a very long time as Realm on FVP is slow and it does
asymmetric cryptography (RSA key generation).

# Verification success

When verification succeeds, both `rsictl` and `realm-verifier` should not
output any errors. For both binaries you can set RUST_LOG
environmental variable to change log level (info, debug):

Realm:

    shared # RUST_LOG=info ./rsictl ra-tls -r root-ca.crt -u <SERVER_IP:PORT>

Reliant party:

    CCA/realm-verifier $ RUST_LOG=info cargo run -- -r <path/to/realm.json> -b <LOCAL_IP:PORT>

With that log level realm client should report successful socket write
with 'GIT' message and verifying server should output that message.
